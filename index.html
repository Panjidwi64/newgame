<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ethOS Cinema</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui,Arial}
    #hint{position:fixed;left:12px;bottom:10px;color:#aaa;font-size:12px;opacity:.8}
  </style>
</head>
<body>
  <div id="hint">Click to enter, use WASD to move, mouse to look around</div>

  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js?module";
    import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js?module";

    // --- scene setup ---
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x080a12);

    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(0, 1.25, 7);

    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    // --- PointerLockControls ---
    const controls = new PointerLockControls(camera, document.body);
    scene.add(controls.getObject());
    document.body.addEventListener('click', () => controls.lock());

    // --- movement flags (WASD) ---
    const move = { forward:false, backward:false, left:false, right:false };
    addEventListener('keydown',(e)=>{
      if(e.code==="KeyW") move.forward = true;
      if(e.code==="KeyS") move.backward = true;
      if(e.code==="KeyA") move.left = true;
      if(e.code==="KeyD") move.right = true;
    });
    addEventListener('keyup',(e)=>{
      if(e.code==="KeyW") move.forward = false;
      if(e.code==="KeyS") move.backward = false;
      if(e.code==="KeyA") move.left = false;
      if(e.code==="KeyD") move.right = false;
    });

    // --- room ---
    const room = new THREE.Mesh(
      new THREE.BoxGeometry(24, 12, 24),
      new THREE.MeshStandardMaterial({ color:0x1a1d27, side:THREE.BackSide, roughness:0.9 })
    );
    scene.add(room);

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(24, 24),
      new THREE.MeshStandardMaterial({ color:0x20242f, roughness:0.8 })
    );
    floor.rotation.x = -Math.PI/2;
    scene.add(floor);

    // --- screen ---
    const video = document.createElement('video');
    video.src = "media/ad1.mp4";
    video.loop = true; video.muted = true; video.autoplay = true; video.playsInline = true;
    video.play();

    const videoTex = new THREE.VideoTexture(video);
    videoTex.colorSpace = THREE.SRGBColorSpace;

    const screenW = 12, screenH = screenW * 8/16;
    const screen = new THREE.Mesh(
      new THREE.PlaneGeometry(screenW, screenH),
      new THREE.MeshBasicMaterial({ map: videoTex })
    );
    screen.position.set(0, 4, -11.8);
    scene.add(screen);

    const frame = new THREE.Mesh(
      new THREE.PlaneGeometry(screenW+1, screenH+1),
      new THREE.MeshBasicMaterial({ color:0x0f1015 })
    );
    frame.position.copy(screen.position);
    frame.position.z -= 0.01;
    scene.add(frame);

    // --- lighting ---
    scene.add(new THREE.AmbientLight(0xffffff, 0.45));
    const projector = new THREE.SpotLight(0xffffff, 1.2, 0, Math.PI/7, 0.25, 1.5);
    projector.position.set(0, 3.5, 7);
    projector.target = screen;
    scene.add(projector);

    const wallLight1 = new THREE.PointLight(0xffddaa, 0.6, 10);
    wallLight1.position.set(-10, 4, 0);
    scene.add(wallLight1);

    const wallLight2 = new THREE.PointLight(0xffddaa, 0.6, 10);
    wallLight2.position.set(10, 4, 0);
    scene.add(wallLight2);

    // --- audience ---
    const audience = new THREE.Group();
    const matHead = new THREE.MeshStandardMaterial({ color:0x222831, roughness:0.6, metalness:0.2 });
    const matBody = new THREE.MeshStandardMaterial({ color:0x303844, roughness:0.7, metalness:0.2 });

    for (let row=0; row<4; row++){
      for (let col=-4; col<=4; col++){
        const x = col*0.9;
        const z = 4.5 - row*1.2;
        const head = new THREE.Mesh(new THREE.SphereGeometry(0.22, 16, 12), matHead);
        head.position.set(x, 1.1, z);
        audience.add(head);
        const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.3, 0.6, 16), matBody);
        body.position.set(x, 0.75, z);
        audience.add(body);
      }
    }
    scene.add(audience);

    // --- movement update ---
    function updateMovement(dt) {
      const speed = 5.0;
      if (move.forward) controls.moveForward(speed * dt);
      if (move.backward) controls.moveForward(-speed * dt);
      if (move.left) controls.moveRight(-speed * dt);
      if (move.right) controls.moveRight(speed * dt);
    }

    // --- Confetti 3D ---
    const confettiGroup = new THREE.Group();
    scene.add(confettiGroup);

    const confettiColors = [0xff3b3b, 0x3bff65, 0x3b9bff, 0xfff63b, 0xff3be3];

    function createConfettiPiece() {
      const size = Math.random() * 0.2 + 0.05;
      const geometry = new THREE.PlaneGeometry(size, size*1.5);
      const material = new THREE.MeshBasicMaterial({ 
        color: confettiColors[Math.floor(Math.random()*confettiColors.length)], 
        side: THREE.DoubleSide 
      });
      const piece = new THREE.Mesh(geometry, material);
      piece.position.set(
        (Math.random() - 0.5) * 20,
        6 + Math.random() * 5,
        (Math.random() - 0.5) * 20
      );
      piece.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
      piece.userData = {
        velocityY: Math.random() * -0.02 - 0.01,
        rotationSpeed: new THREE.Vector3(
          (Math.random()-0.5)*0.02,
          (Math.random()-0.5)*0.02,
          (Math.random()-0.5)*0.02
        )
      };
      return piece;
    }

    const confettiCount = 150;
    for (let i=0; i<confettiCount; i++){
      confettiGroup.add(createConfettiPiece());
    }

    function updateConfetti() {
      confettiGroup.children.forEach(piece => {
        piece.position.y += piece.userData.velocityY;
        piece.rotation.x += piece.userData.rotationSpeed.x;
        piece.rotation.y += piece.userData.rotationSpeed.y;
        piece.rotation.z += piece.userData.rotationSpeed.z;
        if (piece.position.y < 0.1) {
          piece.position.y = 6 + Math.random() * 5;
          piece.position.x = (Math.random() - 0.5) * 20;
          piece.position.z = (Math.random() - 0.5) * 20;
        }
      });
    }

    // --- animation loop ---
    const clock = new THREE.Clock();
    function animate(){
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      updateMovement(dt);
      updateConfetti();
      renderer.render(scene,camera);
    }
    animate();

    addEventListener('resize',()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });

    // --- Banner Slideshow ---
    const textureLoader = new THREE.TextureLoader();
    const bannerImages = [
      "logo.png",
      "banner1.png",
      "banner2.png",
      "banner3.png"
    ];
    let currentBannerIndex = 0;
    const banners = [];

    const bannerTexture = textureLoader.load(bannerImages[currentBannerIndex]);
    const bannerMaterial = new THREE.MeshBasicMaterial({ 
      map: bannerTexture, 
      side: THREE.DoubleSide, 
      transparent: true, 
      opacity: 1 
    });

    const bannerGeometry = new THREE.PlaneGeometry(5, 2.5);
    const bannerLeft = new THREE.Mesh(bannerGeometry, bannerMaterial.clone());
    bannerLeft.position.set(-8, 3, -5); 
    bannerLeft.rotation.y = Math.PI / 2;
    scene.add(bannerLeft);
    banners.push(bannerLeft);

    const bannerRight = bannerLeft.clone();
    bannerRight.position.set(8, 3, -5); 
    bannerRight.rotation.y = -Math.PI / 2;
    scene.add(bannerRight);
    banners.push(bannerRight);

    const bannerBack = bannerLeft.clone();
    bannerBack.position.set(0, 3, 10); 
    bannerBack.rotation.y = Math.PI;
    scene.add(bannerBack);
    banners.push(bannerBack);

    for (let i = 0; i < 4; i++) {
      const smallBannerGeo = new THREE.PlaneGeometry(2, 1);
      const smallBannerLeft = new THREE.Mesh(
        smallBannerGeo,
        bannerMaterial.clone()
      );
      smallBannerLeft.position.set(-10, 1.5 + i * 1.5, -2); 
      smallBannerLeft.rotation.y = Math.PI / 2;
      scene.add(smallBannerLeft);
      banners.push(smallBannerLeft);

      const smallBannerRight = new THREE.Mesh(
        smallBannerGeo,
        bannerMaterial.clone()
      );
      smallBannerRight.position.set(10, 1.5 + i * 1.5, -2);
      smallBannerRight.rotation.y = -Math.PI / 2;
      scene.add(smallBannerRight);
      banners.push(smallBannerRight);
    }

    function changeBanner() {
      let opacity = 1;
      const fadeOut = setInterval(() => {
        opacity -= 0.05;
        banners.forEach(banner => {
          banner.material.opacity = Math.max(0, opacity);
        });

        if (opacity <= 0) {
          clearInterval(fadeOut);
          currentBannerIndex = (currentBannerIndex + 1) % bannerImages.length;
          const newTexture = textureLoader.load(bannerImages[currentBannerIndex]);
          banners.forEach(banner => {
            banner.material.map = newTexture;
            banner.material.needsUpdate = true;
          });
          let opacityIn = 0;
          const fadeIn = setInterval(() => {
            opacityIn += 0.05;
            banners.forEach(banner => {
              banner.material.opacity = Math.min(1, opacityIn);
            });
            if (opacityIn >= 1) clearInterval(fadeIn);
          }, 50);
        }
      }, 50);
    }

    setInterval(changeBanner, 5000);

  </script>
</body>
</html>
